<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - Z51 MDIS5 Driver - Main Page</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;">
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z51 MDIS5 Driver &nbsp; </h1>
	<h3>Main Page</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>Z51 MDIS5 Driver Documentation</h1>
<p>
This is the documentation of the MDIS5 low-level driver for the DAC8532 digital-to-analog-converter connected to the system via the 16Z051 "Edmonton" interface implemented in FPGA.<h2><a name="Variants"></a>
Variants</h2>
In order to support different CPU/carrier board combinations and to achieve maximum performance, the Z51 driver can be built in some variants at compilation time:<p>
<div class="fragment"><pre>    Driver              Variant Description
    --------            --------------------------------
    Standard            D32 <span class="keyword">register</span> access, non-swapped
    _sw                 D32 <span class="keyword">register</span> access, swapped
</pre></div><p>
Here are some combinations of MEN CPU and carrier boards together with the required variants:<p>
<div class="fragment"><pre>    CPU                    Carrier Board          Driver Variant
    ----------------       -------------          --------------
    MEN EM04 (PPC)         (none)                 _sw
    MEN F7 (Pentium CPCI)   F401                  Standard
</pre></div><p>
<br>
 <h2><a name="FuncDesc"></a>
Functional Description</h2>
<br>
 <h3><a name="General"></a>
General</h3>
The DAC8532 features two independant channels with a resolution of 16 bits each. The output value of the channels can be set either sequencially or simultaneously both at-once. The DAC8532 has a built-in SPI interface, which is handled by the 16Z051 FPGA unit. The driver uses its registers to send commands and data to the DAC.<p>
<br>
 <h3><a name="channels"></a>
Logical channels</h3>
The driver supports three logical channels:<ul>
<li>Channel 0: DAC channel A</li><li>Channel 1: DAC channel B</li><li>Channel 2: DAC channels A and B</li></ul>
<p>
Note: <a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a13">M_setstat()</a> and <a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a12">M_getstat()</a> can only be used for channel 0 or 1.<p>
Using <a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_write()</a> a 16-bit value can be written on channels 0 and 1 which determines the voltage/current on DAC channel A or B respectively. <a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_write()</a> on channel 2 expects a 32-bit argument which is composed of the 16-bit values that will be written to channels A and B:<p>
<div class="fragment"><pre>    <a class="codeRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_write</a>( (ch_b_value &lt;&lt; 16) | ch_a_value );
</pre></div><p>
Writing on channel 2 causes both DAC channels to be updated simultaneously.<p>
<br>
 <h3><a name="calibration"></a>
Calibration</h3>
Calibration of the DACs is done by default values for gain and offset which are compiled into the driver. If necessary these can be overwritten using the descriptor keys Z51_GAIN/Z51_OFFSET. Using SetStat calls Z51_GAIN and Z51_OFFSET the driver can be forced to use the given values for calibration. The calibration itself is calculated using this formula:<p>
<div class="fragment"><pre>    y = <a class="code" href="z51__drv_8h.html#a0">Z51_OFFSET</a> + x * <a class="code" href="z51__drv_8h.html#a1">Z51_GAIN</a> / 0xFFFF
</pre></div><p>
where y is the value written into the DAC's input register; x is the value set by <a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_write()</a>. Z51_OFFSET is the value that must be written to the DAC to get the minimum intended voltage/current at the output, Z51_GAIN is the DAC's value for the maximum voltage/current.<p>
<br>
 If Z51_GAIN is zero, then no calibration is done. In this case the values given by <a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_write()</a> are written to the DAC without change.<p>
<br>
 <h3><a name="interrupt"></a>
Interrupt handling</h3>
In case of hardware malfunction the FPGA can generate an interrupt. The driver catches this interrupt and sends an user defineable signal to the application. Interrupt generation and handling can be enabled using descriptor key Z51_INTERRUPT. By default it is disabled.<p>
<br>
 The signal must be activated via the Z51_SIG_SET SetStat code and can be cleared through SetStat Z51_SIG_CLR.<p>
<br>
 <h3><a name="powerdown"></a>
Power Down</h3>
The driver allows to set each of the DAC's channels into one of four supported power-down modes. This is done using SetStat Z51_POWERDOWN on the respective logical channel (0 or 1).<p>
<dl compact><dt><b>Warning:</b></dt><dd>On Power Down the outputs of the DAC8532 are set High-Z or tied to ground. If this feature is useful or even applicable depends on the circuity at the DAC's output on your board. <b> Use with care !</b></dd></dl>
<br>
 Power Down modes:<ul>
<li>0: Output active</li><li>1: Output High-Z</li><li>2: Output tied to ground by internal 1kOhm resistor</li><li>3: Output tied to ground by internal 100kOhm resistor</li></ul>
<p>
The current power-down mode can be obtained using SetStat Z51_POWERDOWN.<p>
<br>
 <h3><a name="watchdog"></a>
Watchdog</h3>
The F401 board contains a watchdog circuit which supervises the DAC. If no SPI communication is running between the FPGA and the DAC 8532 then the DAC's output is disconnected from the board's output drivers. In this driver this mechanism is used to ensure an output curent of 0 mA when the driver is not initialized. <br>
<p>
The communication is established on the first <a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_write()</a> access and turned off when the last instance of the driver is closed. <br>
<p>
The watchdog generates also an interrupt if no communication is detected. Therefore when the first access is done and IRQs are enabled the driver waits about 1000ms for the watchdog circuit to release the IRQ input before it enables the interrupt. This avoids an unwanted interrupt which else would happen on first access. If the driver's interrupt is used (descriptor key IRQ_ENABLE) this causes a delay on the first <a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_write()</a>.<p>
If the interrupts triggers, which happens in case of a hardware malfunction, a signal is optionally sended to the application and the interrupt is disabled until the next <a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_write()</a> call.<p>
<br>
 <h3><a name="locking"></a>
Locking Mode</h3>
This driver uses call-locking.<p>
<br>
 <h2><a name="api_functions"></a>
Supported API Functions</h2>
<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td><b>API function</b> </td><td><b>Functionality</b> </td><td><b>Corresponding low level function</b><p>
</td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a4">M_open()</a></td><td>Open device</td><td><a class="el" href="z51__drv_8c.html#a28">Z51_Init()</a><p>
</td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a9">M_close()</a> </td><td>Close device  </td><td><a class="el" href="z51__drv_8c.html#a29">Z51_Exit()</a>) </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a10">M_read()</a> </td><td>Read from device  </td><td><a class="el" href="z51__drv_8c.html#a30">Z51_Read()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_write()</a> </td><td>Write to device  </td><td><a class="el" href="z51__drv_8c.html#a31">Z51_Write()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a13">M_setstat()</a> </td><td>Set device parameter  </td><td><a class="el" href="z51__drv_8c.html#a32">Z51_SetStat()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a12">M_getstat()</a> </td><td>Get device parameter  </td><td><a class="el" href="z51__drv_8c.html#a33">Z51_GetStat()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a14">M_getblock()</a> </td><td>Block read from device  </td><td><a class="el" href="z51__drv_8c.html#a34">Z51_BlockRead()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a15">M_setblock()</a> </td><td>Block write from device  </td><td><a class="el" href="z51__drv_8c.html#a35">Z51_BlockWrite()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/m__errstr_8c.html#a1">M_errstringTs()</a> </td><td>Generate error message  </td><td>- </td></tr>
</table>
<p>
<br>
 <h2><a name="descriptor_entries"></a>
Descriptor Entries</h2>
The low-level driver initialization routine decodes the following entries ("keys") in addition to the general descriptor keys:<p>
<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td><b>Descriptor entry</b> </td><td><b>Description</b> </td><td><b>Values</b> <p>
</td></tr>
<tr>
<td>Z51_INTERRUPT </td><td>Interrupt active </td><td>0..1, default: 0  </td></tr>
<tr>
<td>Z51_OFFSET_0 </td><td>Offset value for calibration </td><td>0..0xffff, default: 0x1985  </td></tr>
<tr>
<td>Z51_GAIN_0 </td><td>Gain value for calibration </td><td>0..0xffff, default: 0xCE3E  </td></tr>
<tr>
<td>Z51_OFFSET_1 </td><td>Offset value for calibration </td><td>0..0xffff, default: 0x1951  </td></tr>
<tr>
<td>Z51_GAIN_1 </td><td>Gain value for calibration </td><td>0..0xffff, default: 0xCDD3  </td></tr>
</table>
<p>
<br>
 <h2><a name="codes"></a>
Z51 specific Getstat/Setstat codes</h2>
see <a class="el" href="z51__drv_8h.html#getstat_setstat_codes">section about Getstat/Setstat codes</a><p>
<br>
 <h2><a name="Documents"></a>
Overview of all Documents</h2>
<h3><a name="z51_simp"></a>
Simple example for using the driver</h3>
<a class="el" href="z51__simp_8c.html">z51_simp.c</a> (see example section)
	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for Z51 MDIS5 Driver using <a href="http://www.doxygen.org">doxygen</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>

